<link rel="stylesheet" type="text/css" href="css/component.css" />

<script src=lib2.js></script>

<body bgcolor=black>
   <div id="div1">
      <nav class = "cl-effect-21">
         <a href="graphics.html" class="active"> Back to Graphics Projects</a>
      </nav>
      <br><br><br><br>
      <center>
         <p style="color: white;"> Work with raytracing using the Phong Reflection model.</p>
         <td><canvas id='canvas1' width=400 height=400></canvas></td>
      </center>
   </div>
</body>

<script>

   // IMPLEMENT A VECTOR NORMALIZE FUNCTION IN JAVASCRIPT.
   function normalize(vec) {
      var norm = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);
      for (var i = 0 ; i < 3 ; i++)
         vec[i] /= norm;
   }

   // SPECIFY HOW MANY LIGHT SOURCES FOR THE FRAGMENT SHADER TO LOOP THROUGH.
   var nLights = 3;

   // MAINTAIN AN ARRAY OF LIGHT DIRECTION VALUES.
   var lDirValues;
   var sValues;
   var specValues;
   var power;
   var lColorValues;
   var ambientValues;
   var diffuseValues;

   // UPDATE FUNCTION IS CALLED BY THE LIBRARY BEFORE RENDERING, ONCE PER ANIMATION FRAME.
   var update = function() {

      // AT EACH ANIMATION FRAME, COMPUTE THE LIGHT DIRECTIONS.
      var x = Math.sin(Math.PI * time );
      var y = Math.cos(.5 * time);

      // Light direction variables
      var lDir0 = [x,x,1];
      var lDir1 = [-1,-1,-1];
      var lDir2 = [y, x, 5];
      normalize(lDir0);
      normalize(lDir1);
      normalize(lDir2);

      lDirValues = [];
      lDirValues.push(lDir0[0], lDir0[1], lDir0[2]);
      lDirValues.push(lDir1[0], lDir1[1], lDir1[2]);
      lDirValues.push(lDir2[0], lDir2[1], lDir2[2]);

      // Light color variables
      var lColor0 = [.16, .82, .78];
      var lColor1 = [.87, .1, .58];
      var lColor2 = [.3, 1., .08];

      lColorValues = [];
      lColorValues.push(lColor0[0], lColor0[1], lColor0[2]);
      lColorValues.push(lColor1[0], lColor1[1], lColor1[2]);
      lColorValues.push(lColor2[0], lColor2[1], lColor2[2]);

      var a = Math.sin(time * 2.);
      var b = Math.cos(time * 2.);
      var c = Math.sin(time);

      var sphere0 = [.25, a, -3. + c, .35];
      var sphere1 = [a, b, -2.8, .15];
      var sphere2 = [.0 , .5 * b , -2.8 + c , .15 + -c/3];
      var sphere3 = [-.3 * b, .8 * c, -2.8 + c, .10];

      sValues = [];
      sValues.push(sphere0[0],sphere0[1],sphere0[2],sphere0[3]);
      sValues.push(sphere1[0],sphere1[1],sphere1[2],sphere1[3]);
      sValues.push(sphere2[0],sphere2[1],sphere2[2],sphere2[3]);
      sValues.push(sphere3[0],sphere3[1],sphere3[2],sphere3[3]);

      specValues = [.4, .4, .4];

      power = 3.;

      ambientValues = [.01, .01, .01];

      diffuseValues = [.01, .01, .01, .9, .9, .9];
   }

</script>

<script id='my_vertex_shader' type='x-shader/x-vertex'> 
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader' type='x-shader/x-fragment'>
   precision mediump float;
   uniform vec3  uCursor;
   uniform vec3  uLDir[20];  // WE ADDED THIS UNIFORM
   uniform vec3  uLColors[3];

   uniform vec4  uSValues[4];

   uniform vec3  uSpecVal;
   uniform vec3  uAmbVal;
   uniform vec3  uDiffVal[2];
   uniform float uPower;

   uniform float uTime;
   uniform int   uNLights;   // WE ADDED THIS UNIFORM
   varying vec3  vPosition;

   // ambient AND diffuse, BELOW, ARE SUFFICIENT TO CREATE ONLY DIFFUSE MATERIALS.

   // YOU NEED TO ADD specular AND power TO IMPLEMENT THE PHONG SHADING ALGORITHM.
   // FOR EXTRA CREDIT, YOU CAN MAKE THESE ARRAYS TO IMPLEMENT MULTIPLE MATERIALS.
   
   // COMPUTE THE INTERSECTION OF A RAY WITH A SPHERE, IF ANY.
   float raySphere(vec3 V, vec3 W, vec4 sph) {
      vec3 D = V - sph.xyz;
      float b = 2. * dot(W, D);
      float c = dot(D, D) - sph.w * sph.w;
      float discr = b * b - 4. * c;
      return discr >= 0. ? (-b - sqrt(discr)) / 2. : 10000.;
   }

   // YOU NEED TO CHANGE THIS TO USE THE PHONG SHADING ALGORITHM.
   //vec3 shadeSphere(vec3 point, vec4 sphere, vec3 W, vec3 diffuse, vec3 specular) {
   vec3 shadeSphere(vec3 point, vec4 sphere, vec3 W, vec3 uDiffVal, vec3 uSpecVal) {

      vec3 normal = (point - sphere.xyz) / sphere.w;
      vec3 shade = uAmbVal;

      // LOOP THROUGH THE FIRST uNlights LIGHT SOURCES.
      for (int i = 0 ; i < 20 ; i++){
         if (i < uNLights){
            vec3 R = 2. * normal * dot(normal, uLDir[i]) - uLDir[i];
            float maximum = max(.0, dot(-W, R));
            shade += uLColors[i] * ((uDiffVal * max(.0, dot(normal, uLDir[i]))) + uSpecVal * pow(maximum, uPower));
         }
      }
      return shade;
   }

   void main(void) {

      // COMPUTE V AND W TO CREATE THE RAY FOR THIS PIXEL, USING vPosition.x AND vPosition.y.
      vec3 V = vec3(0., 0., 0.);
      vec3 W = normalize(vec3(vPosition.xy, -3.));

      vec3 color = vec3(.05, .05, .05);         // BACKGROUND COLOR
      
      float min = 10000.;                      // KEEP TRACK OF SMALLEST t

      for(int i = 0; i < 4; i++){
         float t = raySphere(V, W, uSValues[i]);
         if(t < min){
            min = t;
            color = shadeSphere(V + t * W, uSValues[i], W, uDiffVal[i], uSpecVal);
         }
      }

      color.r *= .5 + sin(2. * uTime);
      color = sqrt(color);                   // DO GAMMA CORRECTION.

      gl_FragColor = vec4(color, 1.);        // SET OPACITY TO 1.
   }
</script>

<script>
start_gl('canvas1', document.getElementById('my_vertex_shader'  ).innerHTML,
                    document.getElementById('my_fragment_shader').innerHTML);
</script>


